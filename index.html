<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ULTIMATE JS-CRAFT</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid #fff; 
                     transform: translate(-50%, -50%); mix-blend-mode: difference; opacity: 0.8; }

        /* Hotbar */
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; 
                  background: rgba(0,0,0,0.8); padding: 5px; border: 4px solid #333; border-radius: 10px; 
                  box-shadow: 0 0 15px rgba(0,0,0,0.5); pointer-events: auto; }
        .slot { width: 50px; height: 50px; border: 3px solid #555; margin: 2px; display: flex; 
                align-items: center; justify-content: center; background: #8b8b8b; position: relative; 
                cursor: pointer; border-radius: 5px; }
        .slot.active { border-color: #fff; box-shadow: 0 0 10px #fff, inset 0 0 10px rgba(255,255,255,0.3); }
        .slot img { width: 100%; height: 100%; image-rendering: pixelated; }

        /* Inventory Screen */
        #inventory { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                      background: #c6c6c6; border: 6px solid #444; display: none; padding: 20px; 
                      pointer-events: auto; z-index: 100; border-radius: 10px; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        .inv-grid { display: grid; grid-template-columns: repeat(9, 50px); gap: 5px; margin-bottom: 20px; }
        
        #debug { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 12px; 
                 pointer-events: none; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; }
        
        .block-indicator { position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); 
                          color: white; font-size: 14px; background: rgba(0,0,0,0.7); padding: 2px 8px; 
                          border-radius: 3px; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                   color: white; font-size: 24px; background: rgba(0,0,0,0.8); padding: 20px; 
                   border-radius: 10px; z-index: 1000; }
    </style>
</head>
<body>

<div id="debug">FPS: <span id="fps">60</span> | POS: <span id="pos">0,0,0</span> | ЧАНК: <span id="chunk">0,0</span></div>
<div id="crosshair"></div>
<div class="block-indicator" id="block-indicator"></div>

<div id="inventory">
    <div style="margin-bottom:10px; font-weight:bold; color:#333; text-align:center; font-size:18px;">
        ИНВЕНТАРЬ (E - закрыть)
    </div>
    <div id="inv-main" class="inv-grid"></div>
    <div style="margin-bottom:10px; font-weight:bold; color:#333;">ХОТБАР</div>
    <div id="inv-hotbar" class="inv-grid"></div>
</div>

<div id="ui-layer">
    <div id="hotbar"></div>
</div>

<div id="loading">Загрузка мира...</div>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

// --- НАСТРОЙКИ ---
const CHUNK_SIZE = 16;
const WORLD_HEIGHT = 128;
const RENDER_DISTANCE = 4;
const TEXTURE_SIZE = 16;

// --- ПРОСТОЙ ШУМ ДЛЯ ГЕНЕРАЦИИ ---
class SimpleNoise {
    constructor(seed = 12345) {
        this.seed = seed;
    }
    
    hash(x, y) {
        let h = this.seed + x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return (h ^ (h >> 16)) / 4294967296;
    }
    
    noise(x, y) {
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        const fx = x - ix;
        const fy = y - iy;
        
        const a = this.hash(ix, iy);
        const b = this.hash(ix + 1, iy);
        const c = this.hash(ix, iy + 1);
        const d = this.hash(ix + 1, iy + 1);
        
        const ux = fx * fx * (3 - 2 * fx);
        const uy = fy * fy * (3 - 2 * fy);
        
        return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
    }
    
    octaveNoise(x, y, octaves = 4, persistence = 0.5) {
        let total = 0;
        let frequency = 1;
        let amplitude = 1;
        let maxValue = 0;
        
        for(let i = 0; i < octaves; i++) {
            total += this.noise(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2;
        }
        
        return total / maxValue;
    }
}

// --- ТЕКСТУРЫ ---
function createBlockTexture(color, type = 'basic') {
    const canvas = document.createElement('canvas');
    canvas.width = TEXTURE_SIZE;
    canvas.height = TEXTURE_SIZE;
    const ctx = canvas.getContext('2d');
    
    const baseColor = new THREE.Color(color);
    ctx.fillStyle = baseColor.getStyle();
    ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
    
    // Добавляем детали
    for(let i = 0; i < 30; i++) {
        const x = Math.floor(Math.random() * TEXTURE_SIZE);
        const y = Math.floor(Math.random() * TEXTURE_SIZE);
        const shade = 0.7 + Math.random() * 0.6;
        const pixelColor = baseColor.clone().multiplyScalar(shade);
        ctx.fillStyle = pixelColor.getStyle();
        ctx.fillRect(x, y, 1, 1);
    }
    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = canvas.toDataURL();
    });
}

const BLOCK_DATA = {
    0: { name: 'Air', solid: false, transparent: true },
    1: { name: 'Grass', color: '#4dbb28', solid: true },
    2: { name: 'Dirt', color: '#8b5a29', solid: true },
    3: { name: 'Stone', color: '#808080', solid: true },
    4: { name: 'Wood', color: '#8b4513', solid: true },
    5: { name: 'Leaves', color: '#32a852', solid: true, transparent: true },
    6: { name: 'Sand', color: '#e0c060', solid: true },
    7: { name: 'Water', color: '#3a7fc8', solid: false, transparent: true, liquid: true },
    8: { name: 'Coal Ore', color: '#333333', solid: true },
    9: { name: 'Iron Ore', color: '#d8d8d8', solid: true },
    10: { name: 'Diamond Ore', color: '#2acaea', solid: true }
};

// --- 3D РУКА ---
class Hand3D {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.hand = null;
        this.bobTime = 0;
        this.swingTime = 0;
        this.isSwinging = false;
        
        this.createHand();
    }
    
    createHand() {
        const group = new THREE.Group();
        
        // Рука (синий рукав как в Minecraft)
        const handGeometry = new THREE.BoxGeometry(0.3, 0.9, 0.3);
        const handMaterial = new THREE.MeshLambertMaterial({ color: 0x3c44aa });
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        hand.position.set(0.4, -0.8, -0.5);
        group.add(hand);
        
        // Кисть (кожа)
        const armGeometry = new THREE.BoxGeometry(0.25, 0.4, 0.25);
        const armMaterial = new THREE.MeshLambertMaterial({ color: 0xf1c27d });
        const arm = new THREE.Mesh(armGeometry, armMaterial);
        arm.position.set(0.4, -1.25, -0.5);
        group.add(arm);
        
        this.hand = group;
        this.scene.add(this.hand);
        
        // Предмет в руке
        this.itemGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        this.itemMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
        this.currentItem = new THREE.Mesh(this.itemGeometry, this.itemMaterial);
        this.currentItem.position.set(0.4, -1.0, -0.3);
        this.currentItem.visible = false;
        this.hand.add(this.currentItem);
    }
    
    updateItem(blockId) {
        if (blockId && blockId > 0 && BLOCK_DATA[blockId]) {
            this.itemMaterial.color.set(BLOCK_DATA[blockId].color);
            this.currentItem.visible = true;
        } else {
            this.currentItem.visible = false;
        }
    }
    
    update(deltaTime, velocity, onGround) {
        if (!this.hand) return;
        
        // Позиция руки относительно камеры
        this.hand.position.copy(this.camera.position);
        this.hand.rotation.copy(this.camera.rotation);
        
        // Покачивание при ходьбе
        let bobOffset = 0;
        let swingOffset = 0;
        
        if (onGround && (Math.abs(velocity.x) > 0.01 || Math.abs(velocity.z) > 0.01)) {
            this.bobTime += deltaTime * 10;
            bobOffset = Math.sin(this.bobTime) * 0.05;
        }
        
        // Анимация удара
        if (this.isSwinging) {
            this.swingTime += deltaTime * 15;
            const progress = Math.min(this.swingTime, 1);
            swingOffset = Math.sin(progress * Math.PI) * -0.5;
            
            if (progress >= 1) {
                this.isSwinging = false;
                this.swingTime = 0;
            }
        }
        
        // Применяем смещение
        this.hand.position.x += 0.3;
        this.hand.position.y += -0.5 + bobOffset + swingOffset * 0.5;
        this.hand.position.z += -0.7 + swingOffset;
        
        // Легкий наклон при покачивании
        if (bobOffset > 0) {
            this.hand.rotation.z = Math.sin(this.bobTime * 2) * 0.05;
        } else {
            this.hand.rotation.z = 0;
        }
    }
    
    swing() {
        this.isSwinging = true;
        this.swingTime = 0;
    }
}

// --- ОСНОВНОЙ ДВИЖОК ---
let scene, camera, renderer, controls, hand3D;
let chunks = new Map();
let inventory = Array(36).fill({ id: 0, count: 0 }); // ПУСТОЙ инвентарь
let selectedSlot = 0;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let onGround = false;
let lastTime = 0;
let raycaster = new THREE.Raycaster();
let lookingAtBlock = null;
let blockMaterials = {};
let noise = new SimpleNoise();

async function init() {
    try {
        // Сцена
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 200);
        
        // Камера
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 70, 0);
        
        // Рендерер
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Управление
        controls = new PointerLockControls(camera, document.body);
        
        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 200, 100);
        scene.add(directionalLight);
        
        // Создаем текстуры и материалы
        await createMaterials();
        
        // Рука
        hand3D = new Hand3D(scene, camera);
        
        // UI
        setupUI();
        setupControls();
        
        // Генерация начального мира
        generateInitialWorld();
        
        // Удаляем экран загрузки
        document.getElementById('loading').style.display = 'none';
        
        lastTime = performance.now();
        animate();
        
    } catch (error) {
        console.error('Ошибка инициализации:', error);
        document.getElementById('loading').innerHTML = 'Ошибка загрузки. Обновите страницу.';
    }
}

async function createMaterials() {
    // Создаем материалы для каждого типа блока
    for (const [id, block] of Object.entries(BLOCK_DATA)) {
        if (id !== '0') {
            const texture = await createBlockTexture(block.color, block.name);
            const canvas = document.createElement('canvas');
            canvas.width = TEXTURE_SIZE;
            canvas.height = TEXTURE_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(texture, 0, 0);
            
            const texture3d = new THREE.CanvasTexture(canvas);
            
            blockMaterials[id] = new THREE.MeshLambertMaterial({
                map: texture3d,
                transparent: block.transparent || false,
                opacity: block.transparent ? 0.7 : 1.0,
                side: THREE.FrontSide
            });
        }
    }
}

// --- ГЕНЕРАЦИЯ МИРА ---
function generateInitialWorld() {
    const startX = Math.floor(camera.position.x / CHUNK_SIZE);
    const startZ = Math.floor(camera.position.z / CHUNK_SIZE);
    
    console.log('Генерация мира вокруг:', startX, startZ);
    
    for (let x = startX - RENDER_DISTANCE; x <= startX + RENDER_DISTANCE; x++) {
        for (let z = startZ - RENDER_DISTANCE; z <= startZ + RENDER_DISTANCE; z++) {
            generateChunk(x, z);
        }
    }
    
    console.log('Чанков сгенерировано:', chunks.size);
}

function getHeight(x, z) {
    // Основная высота
    let height = noise.octaveNoise(x * 0.01, z * 0.01, 4, 0.5);
    height = 60 + height * 40; // Высота от 20 до 100
    
    // Добавляем горы
    const mountain = noise.octaveNoise(x * 0.003, z * 0.003, 3, 0.7);
    if (mountain > 0.3) {
        height += mountain * 50;
    }
    
    return Math.floor(Math.max(10, Math.min(WORLD_HEIGHT - 10, height)));
}

function getBlockType(x, y, z) {
    const height = getHeight(x, z);
    
    // Воздух или вода над поверхностью
    if (y > height) {
        if (y < 64 && height < 64) {
            return 7; // Вода
        }
        return 0; // Воздух
    }
    
    // Поверхность
    if (y === height) {
        const biome = noise.noise(x * 0.001, z * 0.001);
        if (biome > 0.3) return 6; // Песок (пустыня)
        return 1; // Трава
    }
    
    // Под поверхностью
    if (y > height - 4) {
        return 2; // Земля
    }
    
    // Пещеры
    if (y < height - 10) {
        const cave = Math.abs(noise.noise(x * 0.05, y * 0.05 + z * 0.05));
        if (cave > 0.7) {
            return 0; // Пещера
        }
    }
    
    // Камень
    return 3;
}

function generateChunk(cx, cz) {
    const key = `${cx},${cz}`;
    if (chunks.has(key)) return;
    
    const chunkMeshes = [];
    
    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
            const worldX = cx * CHUNK_SIZE + lx;
            const worldZ = cz * CHUNK_SIZE + lz;
            
            const height = getHeight(worldX, worldZ);
            
            for (let y = 0; y <= height; y++) {
                const blockType = getBlockType(worldX, y, worldZ);
                
                if (blockType !== 0 && blockMaterials[blockType]) {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = blockMaterials[blockType];
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    mesh.position.set(worldX, y, worldZ);
                    mesh.userData = { type: blockType, x: worldX, y: y, z: worldZ };
                    
                    scene.add(mesh);
                    chunkMeshes.push(mesh);
                }
            }
        }
    }
    
    chunks.set(key, chunkMeshes);
    return chunkMeshes;
}

function updateVisibleChunks() {
    const px = Math.floor(camera.position.x / CHUNK_SIZE);
    const pz = Math.floor(camera.position.z / CHUNK_SIZE);
    
    document.getElementById('chunk').textContent = `${px},${pz}`;
    
    // Удаляем дальние чанки
    const toRemove = [];
    for (const [key, meshes] of chunks) {
        const [cx, cz] = key.split(',').map(Number);
        if (Math.abs(cx - px) > RENDER_DISTANCE || Math.abs(cz - pz) > RENDER_DISTANCE) {
            meshes.forEach(mesh => scene.remove(mesh));
            toRemove.push(key);
        }
    }
    toRemove.forEach(key => chunks.delete(key));
    
    // Генерация новых чанков
    for (let x = px - RENDER_DISTANCE; x <= px + RENDER_DISTANCE; x++) {
        for (let z = pz - RENDER_DISTANCE; z <= pz + RENDER_DISTANCE; z++) {
            const key = `${x},${z}`;
            if (!chunks.has(key)) {
                generateChunk(x, z);
            }
        }
    }
}

// --- UI И ИНВЕНТАРЬ ---
function setupUI() {
    updateHotbar();
}

function updateHotbar() {
    const hotbar = document.getElementById('hotbar');
    hotbar.innerHTML = '';
    
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = `slot ${i === selectedSlot ? 'active' : ''}`;
        slot.dataset.index = i;
        
        const item = inventory[i];
        if (item && item.id > 0 && BLOCK_DATA[item.id]) {
            const canvas = document.createElement('canvas');
            canvas.width = TEXTURE_SIZE;
            canvas.height = TEXTURE_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = BLOCK_DATA[item.id].color;
            ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
            
            // Простая текстура для UI
            for(let j = 0; j < 10; j++) {
                const x = Math.floor(Math.random() * TEXTURE_SIZE);
                const y = Math.floor(Math.random() * TEXTURE_SIZE);
                const shade = 0.8 + Math.random() * 0.4;
                const color = new THREE.Color(BLOCK_DATA[item.id].color).multiplyScalar(shade);
                ctx.fillStyle = color.getStyle();
                ctx.fillRect(x, y, 1, 1);
            }
            
            slot.innerHTML = `
                <img src="${canvas.toDataURL()}" alt="${BLOCK_DATA[item.id].name}">
                <span style="position:absolute; bottom:0; right:2px; color:white; font-size:12px; text-shadow: 1px 1px 2px black;">
                    ${item.count}
                </span>
            `;
        }
        
        slot.addEventListener('click', () => {
            selectedSlot = i;
            updateHotbar();
            hand3D.updateItem(inventory[i].id);
        });
        
        hotbar.appendChild(slot);
    }
    
    // Обновляем предмет в руке
    hand3D.updateItem(inventory[selectedSlot].id);
}

function setupControls() {
    document.addEventListener('keydown', (e) => {
        switch(e.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': 
                if (onGround) {
                    velocity.y = 0.15;
                    onGround = false;
                }
                break;
            case 'KeyE': toggleInventory(); break;
            case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': case 'Digit5':
            case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
                selectedSlot = parseInt(e.key) - 1;
                updateHotbar();
                break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyD': moveRight = false; break;
        }
    });
    
    document.addEventListener('mousedown', (e) => {
        if (!controls.isLocked) {
            controls.lock();
            return;
        }
        
        hand3D.swing();
        
        if (lookingAtBlock) {
            const block = lookingAtBlock.object.userData;
            
            if (e.button === 0) { // ЛКМ - разрушение
                // Удаляем блок из сцены
                scene.remove(lookingAtBlock.object);
                
                // Удаляем из chunks
                const chunkX = Math.floor(block.x / CHUNK_SIZE);
                const chunkZ = Math.floor(block.z / CHUNK_SIZE);
                const key = `${chunkX},${chunkZ}`;
                if (chunks.has(key)) {
                    const meshes = chunks.get(key);
                    const index = meshes.indexOf(lookingAtBlock.object);
                    if (index > -1) {
                        meshes.splice(index, 1);
                    }
                }
                
                // Добавляем блок в инвентарь
                const currentItem = inventory[selectedSlot];
                if (currentItem.id === 0) {
                    currentItem.id = block.type;
                    currentItem.count = 1;
                } else if (currentItem.id === block.type) {
                    currentItem.count = Math.min(currentItem.count + 1, 64);
                }
                updateHotbar();
                
            } else if (e.button === 2) { // ПКМ - установка
                const face = lookingAtBlock.face.normal;
                const newX = block.x + Math.round(face.x);
                const newY = block.y + Math.round(face.y);
                const newZ = block.z + Math.round(face.z);
                
                const currentItem = inventory[selectedSlot];
                if (currentItem.id > 0 && currentItem.count > 0 && blockMaterials[currentItem.id]) {
                    // Проверяем, нет ли уже блока на этой позиции
                    let blockExists = false;
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    for (const intersect of intersects) {
                        if (intersect.object.userData && 
                            intersect.object.userData.x === newX &&
                            intersect.object.userData.y === newY &&
                            intersect.object.userData.z === newZ) {
                            blockExists = true;
                            break;
                        }
                    }
                    
                    if (!blockExists) {
                        // Создаем новый блок
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = blockMaterials[currentItem.id];
                        const newBlock = new THREE.Mesh(geometry, material);
                        
                        newBlock.position.set(newX, newY, newZ);
                        newBlock.userData = { type: currentItem.id, x: newX, y: newY, z: newZ };
                        
                        scene.add(newBlock);
                        
                        // Добавляем в chunk
                        const chunkX = Math.floor(newX / CHUNK_SIZE);
                        const chunkZ = Math.floor(newZ / CHUNK_SIZE);
                        const key = `${chunkX},${chunkZ}`;
                        if (chunks.has(key)) {
                            chunks.get(key).push(newBlock);
                        }
                        
                        // Обновляем инвентарь
                        currentItem.count--;
                        if (currentItem.count <= 0) {
                            currentItem.id = 0;
                        }
                        updateHotbar();
                    }
                }
            }
        }
    });
    
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    
    renderer.domElement.addEventListener('click', () => {
        if (!controls.isLocked) {
            controls.lock();
        }
    });
}

function updateLookAt() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(scene.children);
    
    if (intersects.length > 0 && intersects[0].object.userData) {
        lookingAtBlock = intersects[0];
        const block = intersects[0].object.userData;
        const blockName = BLOCK_DATA[block.type]?.name || 'Unknown';
        document.getElementById('block-indicator').style.opacity = '1';
        document.getElementById('block-indicator').textContent = blockName;
    } else {
        lookingAtBlock = null;
        document.getElementById('block-indicator').style.opacity = '0';
    }
}

let inventoryOpen = false;
function toggleInventory() {
    inventoryOpen = !inventoryOpen;
    const invUI = document.getElementById('inventory');
    invUI.style.display = inventoryOpen ? 'block' : 'none';
    
    if (inventoryOpen) {
        controls.unlock();
        renderInventoryContent();
    } else {
        controls.lock();
    }
}

function renderInventoryContent() {
    const main = document.getElementById('inv-main');
    const hot = document.getElementById('inv-hotbar');
    main.innerHTML = '';
    hot.innerHTML = '';
    
    inventory.forEach((item, i) => {
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.dataset.index = i;
        
        if (item && item.id > 0 && BLOCK_DATA[item.id]) {
            const canvas = document.createElement('canvas');
            canvas.width = TEXTURE_SIZE;
            canvas.height = TEXTURE_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = BLOCK_DATA[item.id].color;
            ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
            
            slot.innerHTML = `
                <img src="${canvas.toDataURL()}" alt="${BLOCK_DATA[item.id].name}">
                <span style="position:absolute; bottom:0; right:2px; color:white; font-size:12px;">
                    ${item.count}
                </span>
            `;
        }
        
        slot.addEventListener('click', () => {
            if (i < 9) {
                selectedSlot = i;
                updateHotbar();
            }
        });
        
        if (i < 9) hot.appendChild(slot);
        else main.appendChild(slot);
    });
}

// --- ГЛАВНЫЙ ЦИКЛ ---
function animate(currentTime = 0) {
    requestAnimationFrame(animate);
    
    const deltaTime = Math.min(0.1, (currentTime - lastTime) / 1000);
    lastTime = currentTime;
    
    // FPS
    document.getElementById('fps').textContent = Math.floor(1 / deltaTime);
    
    if (controls.isLocked) {
        // Движение
        const speed = 0.1;
        if (moveForward) controls.moveForward(speed);
        if (moveBackward) controls.moveForward(-speed);
        if (moveLeft) controls.moveRight(-speed);
        if (moveRight) controls.moveRight(speed);
        
        // Гравитация
        velocity.y -= 0.02;
        camera.position.y += velocity.y;
        
        // Проверка земли
        const groundHeight = getHeight(camera.position.x, camera.position.z) + 1;
        if (camera.position.y < groundHeight) {
            camera.position.y = groundHeight;
            velocity.y = 0;
            onGround = true;
        } else {
            onGround = false;
        }
        
        // Обновление мира
        updateVisibleChunks();
        updateLookAt();
        
        // Координаты
        document.getElementById('pos').textContent = 
            `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
    }
    
    // Обновление руки
    hand3D.update(deltaTime, velocity, onGround);
    
    // Рендер
    renderer.render(scene, camera);
}

// Обработка ресайза
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Запуск при загрузке
window.addEventListener('DOMContentLoaded', () => {
    setTimeout(init, 100);
});
</script>
</body>
</html>
